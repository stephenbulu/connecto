
<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">

  <title>dumptris</title>
  <meta name="keywords" content="box2d, html5, javascript, game, physics, engine, 2d, web, mobile">
  <style>
      html, body {
        width:  100%;
        height: 100%;
        margin: 0px;
        }
      canvas{
          height:99%;
          margin:0px;
          padding:0px;
      }
  </style>
</head><body>
  <div>
    
  </div>
    <script src="https://d157l7jdn8e5sf.cloudfront.net/v4.8.2/pixi.js"></script>
    <script src="https://s3.amazonaws.com/myamazoncdnbucket/pixi-sound.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/planck-js@0.3.0-rc.1/dist/planck.js"></script>
    <script src="./assets/textures.js"></script>
    <script>
        var sounds = {}
        sounds['pop'] = new PIXI.sound.Sound.from('https://s3.amazonaws.com/myamazoncdnbucket/pop.wav');
        sounds['bounce'] = new PIXI.sound.Sound.from('https://s3.amazonaws.com/myamazoncdnbucket/bounce.mp3');
        sounds['bounce'].volume = .25
        sounds['pop'].volume = .1
        

        var width = 1600;
        var height = 900;
        var wallThickness = 25;
        var leftMargin = 100;
        var rightMargin = 600;
        var pixelToMeterRatio = 40.0;
        function pixelsToMeters(x, y){
            return planck.Vec2((x - leftMargin) / pixelToMeterRatio, (height-y) / pixelToMeterRatio)
        }
        function metersToPixels(x, y){
            return [Math.round(x * pixelToMeterRatio + (leftMargin)), height-y*pixelToMeterRatio]
        }
        function dist(a, b){
            return (Math.abs(a['x'] - b['x'])**2 + Math.abs(a['y'] - b['y'])**2)**.5
        }
        console.log(planck)




        var app = new PIXI.Application(width, height, { antialias: true });

        document.body.appendChild(app.view);


        //var voidFilter = new PIXI.filters.VoidFilter();
        //voidFilter.alpha = 0.5;
        var layerAlphas = [0.05, 0.16, .3, 0.5, 1]
        var shadowLayer = []
        var alphaFilter = []
        for(i=0;i<layerAlphas.length;i++){
            alphaFilter[i] = new PIXI.filters.AlphaFilter();
            alphaFilter[i].alpha = layerAlphas[i];

            shadowLayer[i] = new PIXI.Container();
            shadowLayer[i].filters = [alphaFilter[i]];
            app.stage.addChild(shadowLayer[i]);
        }
        var circlesLayer = new PIXI.Container();
        app.stage.addChild(circlesLayer);


        var uiLayer = new PIXI.Container();
        app.stage.addChild(uiLayer);

  
        var graphics = new PIXI.Graphics();

        // // set a fill and line style
        graphics.beginFill(0x555555);
        graphics.lineStyle(0);

        // draw a shape
        
        graphics.moveTo(leftMargin, 100);
        graphics.lineTo(leftMargin, height-wallThickness);
        graphics.lineTo(width-rightMargin, height-wallThickness);
        graphics.lineTo(width-rightMargin, 100);
        graphics.lineTo(width-rightMargin+wallThickness, 100);
        graphics.lineTo(width-rightMargin+wallThickness, height);
        graphics.lineTo(leftMargin-wallThickness, height);

        graphics.lineTo(leftMargin-wallThickness, 100);
        graphics.lineTo(leftMargin, 100);
        graphics.endFill();

        uiLayer.addChild(graphics);
        var circles = [];


        //Init planck world
        var world = planck.World({
            gravity: planck.Vec2(0, -10)
            //velocityIterations: 30,
            //positionIterations: 30
        });

        var ground = world.createBody({
            type: 'static'
        });
        
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin, height-wallThickness),pixelsToMeters(width-rightMargin, height-wallThickness))
        });
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin, height-wallThickness),pixelsToMeters(leftMargin, 100))
        });
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin, 100),pixelsToMeters(leftMargin-wallThickness, 100))
        });
        
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin+wallThickness, height),pixelsToMeters(leftMargin-wallThickness, 100))
        });
        
        
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(width-rightMargin, height-wallThickness),pixelsToMeters(width-rightMargin, 100))
        });
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(width-rightMargin, 100),pixelsToMeters(width-rightMargin+wallThickness, 100))
        });

        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(width-rightMargin+wallThickness, 100),pixelsToMeters(width-rightMargin+wallThickness, height))
        });

        var blabla = .01
        function addCircle(x, y, color, size){
            //create circle sprite
            var circle = new PIXI.Sprite(circleTextures[color][size]);
            circle.anchor.set(0.5);
            circle.x = x;
            circle.y = y;
            circlesLayer.addChild(circle);

            //create shadow sprite
            var shadow = new PIXI.Sprite(shadowTextures[color][size][0]);
            shadow.anchor.set(0.5);
            shadow.x = x;
            shadow.y = y;
            shadowLayer[0].addChild(shadow);

            // add to global list of sprites
            // circles.push({'circle':circle, 'shadow':shadow});


            body = world.createDynamicBody(pixelsToMeters(x, y));
            body.createFixture({
                shape: planck.Circle((size+1)/pixelToMeterRatio),
                density: blabla,
                friction: 0,
                restitution: 0
            });
            body.setLinearDamping(.2)
            body._circle = circle
            body._shadow = shadow
            body.circleColor = color
            body.circleSize = size
            body.groupSize = 1
            body._edges = []
        }

        function destroySprite(container, sprite){
            container.removeChild(sprite);
        }
        function destroyBody(body){
            sounds['pop'].play();
            world.destroyBody(body)
        }

        console.log(world)
        var joints_to_make = []
        var bodies_to_destroy = []
        world.on('begin-contact', function(fixturePair) {
            body_a = fixturePair.getFixtureA().getBody()
            body_b = fixturePair.getFixtureB().getBody()
            if(body_a.m_type == "static" || body_b.m_type == "static"){
                return
            }
            if(body_a.circleColor != body_b.circleColor){
                return
            }
            if(body_a._edges.includes(body_b)){
                return
            }

            start = body_a.groupSize <= body_b.groupSize ? body_a : body_b
            other = body_a.groupSize <= body_b.groupSize ? body_b : body_a

            if(start == other){console.log("big problems")}

            if(start.groupSize > 1){
                console.log("running special code")
                q = [start]
                visited = [start]     
                while(q.length>0){
                    node = q.pop()
                    if(node == other){
                        //Return if both the bodies are already in the same group
                        return
                    }
                    for(i=0;i<node._edges.length;i++){
                        nNode = node._edges[i]
                        if(! visited.includes(nNode)){
                            q.push(nNode)
                            visited.push(nNode)
                        }
                    }
                }
            }

            sounds['bounce'].play();
            
            body_a._edges.push(body_b)
            body_b._edges.push(body_a)                

            

            newGroupSize = body_a.groupSize + body_b.groupSize

            minGroupSize = 5

            bodyAPos = body_a.getPosition()
            body_a.setLinearVelocity(planck.Vec2(0, 0))
            body_b.setLinearVelocity(planck.Vec2(0, 0))
            bodyBPos = body_b.getPosition()
            jointdef = planck.DistanceJoint(100, body_a, body_b, bodyAPos, bodyBPos)
            jointdef.setLength((body_a.circleSize + body_b.circleSize +1 )/pixelToMeterRatio);
            joints_to_make.push(jointdef)

            q = [body_a]
            visited = [body_a]
            while(q.length>0){
                node = q.pop()
                
                node.groupSize = newGroupSize
                node._shadow.texture = shadowTextures[node.circleColor][node.circleSize][Math.min(newGroupSize-1, 3)];
                node._shadow.setParent(shadowLayer[Math.min(newGroupSize-1, layerAlphas.length-1)])
                
                if(newGroupSize >= minGroupSize){
                    
                    pxCircle = node._circle
                    pxShadow = node._shadow
                    //bodies_to_destroy.push(node)
                    window.setTimeout(destroyBody, 300, node)
                    window.setTimeout(destroySprite, 300, circlesLayer, pxCircle);
                    window.setTimeout(destroySprite, 300, pxShadow.parent, pxShadow);

                }
                

                for(i=0;i<node._edges.length;i++){
                    nNode = node._edges[i]
                    if(! visited.includes(nNode)){
                        q.push(nNode)
                        visited.push(nNode)
                    };
                };
            };
        });
        function bla(){
            randInt = Math.floor(Math.random() * Math.floor(width-leftMargin-rightMargin-100));

            addCircle(randInt+leftMargin+50, -100, ['blue', 'red', 'green', 'purple', 'yellow', 'orange', 'gray'][Math.floor(Math.random() * 7)], [25, 15, 40, 50][Math.floor(Math.random() * 3)])
            window.setTimeout('bla()', 100)
        }
        //window.setTimeout('bla()', 200)
        var binterval = false
        var mousePos = {x:width/2, y:0};
        function addRandCircle(){
            size = [15, 25, 25, 15, 40, 50][Math.floor(Math.random() * 6)]
            
            color = ['blue', 'red', 'green', 'purple', 'yellow', 'orange', 'gray'][Math.floor(Math.random() * 6)]
            mouseX = mousePos.x
            if(mouseX < leftMargin + size){
                mouseX = leftMargin+size
            }
            if(mouseX > width-rightMargin-size){
                mouseX = width-rightMargin-size
            }

            // randInt = Math.floor(Math.random() * Math.floor(width-leftMargin-rightMargin-100));

            addCircle(mouseX, 0, color, size)

            

        }
        app.stage.interactive = true
        app.stage.on('mousemove', function(event){
            mousePos = event.data.getLocalPosition(app.stage)
        });

        window.onmousedown = function(){
            if(binterval === false){
                addRandCircle()
                binterval = window.setInterval('addRandCircle()', 200);
            }
            //randInt = Math.floor(Math.random() * Math.floor(width-leftMargin-rightMargin-100));

            //addCircle(randInt+leftMargin+50, -100, ['blue', 'red', 'green', 'purple', 'yellow', 'orange', 'gray'][Math.floor(Math.random() * 7)], [25, 15, 40, 50][Math.floor(Math.random() * 4)])
        }
        window.onmouseup = function(){
            if(binterval !== false){
                window.clearInterval(binterval)
                binterval = false
            }
        }

        function mainLoop(){
            while(joints_to_make.length > 0){
                jointdef = joints_to_make.pop()
                joint = world.createJoint(jointdef)
            }
            while(bodies_to_destroy.length > 0){
                body = bodies_to_destroy.pop()
                world.destroyBody(body)
            }

            world.step(1 / 100);

            // iterate over bodies and fixtures
            for (var body = world.getBodyList(); body; body = body.getNext()) {
                //console.log(body)
                if(body.m_type == "static"){continue}

                pxCircle = body._circle
                pxShadow = body._shadow
                _ = body.getPosition()
                __ = metersToPixels(_['x'], _['y'])
                pxCircle.x = __[0], pxCircle.y = __[1];
                pxShadow.x = __[0], pxShadow.y = __[1];
            }

            window.requestAnimationFrame(mainLoop);
            
        };

        window.requestAnimationFrame(mainLoop);
        
    </script>
</body></html>
