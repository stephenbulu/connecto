
<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">

  <title>dumptris</title>
  <meta name="keywords" content="box2d, html5, javascript, game, physics, engine, 2d, web, mobile">
  <style>
      html, body {
        width:  100%;
        height: 100%;
        margin: 0px;
        }
      canvas{
          height:100%;
          margin:0px;
          padding:0px;
      }
  </style>
</head><body>
  <div>
    
  </div>
    <script src="https://d157l7jdn8e5sf.cloudfront.net/v4.8.2/pixi.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/planck-js@0.3.0-rc.1/dist/planck.js"></script>
    <script src="./textures.js"></script>
    <script>
        var width = 800;
        var height = 800;
        var wallThickness = 25;
        var leftMargin = 50;
        var rightMargin = 50;
        
        function pixelsToMeters(x, y){
            return planck.Vec2((x - leftMargin) / 80.0, (height-y) / 80.0)
        }
        function metersToPixels(x, y){
            return [Math.round(x * 80.0 + (leftMargin)), height-y*80]
        }
        function dist(a, b){
            return (Math.abs(a['x'] - b['x'])**2 + Math.abs(a['y'] - b['y'])**2)**.5
        }
        console.log(planck)




        var app = new PIXI.Application(width, height, { antialias: true });

        document.body.appendChild(app.view);


        //var voidFilter = new PIXI.filters.VoidFilter();
        //voidFilter.alpha = 0.5;
        var layerAlphas = [0.05, 0.16, .3, 0.5]
        var shadowLayer = []
        var alphaFilter = []
        for(i=0;i<4;i++){
            alphaFilter[i] = new PIXI.filters.AlphaFilter();
            alphaFilter[i].alpha = layerAlphas[i];

            shadowLayer[i] = new PIXI.Container();
            shadowLayer[i].filters = [alphaFilter[i]];
            app.stage.addChild(shadowLayer[i]);
        }
        var circlesLayer = new PIXI.Container();
        app.stage.addChild(circlesLayer);


        var uiLayer = new PIXI.Container();
        app.stage.addChild(uiLayer);

  
        var graphics = new PIXI.Graphics();

        // // set a fill and line style
        graphics.beginFill(0x555555);
        graphics.lineStyle(0);

        // draw a shape
        
        graphics.moveTo(leftMargin, 0);
        graphics.lineTo(leftMargin, height-wallThickness);
        graphics.lineTo(width-rightMargin, height-wallThickness);
        graphics.lineTo(width-rightMargin, 0);
        graphics.lineTo(width-rightMargin+wallThickness, 0);
        graphics.lineTo(width-rightMargin+wallThickness, height);
        graphics.lineTo(leftMargin-wallThickness, height);

        graphics.lineTo(leftMargin-wallThickness, 0);
        graphics.lineTo(leftMargin, 0);
        graphics.endFill();

        uiLayer.addChild(graphics);
        var circles = [];

        var world = planck.World({
            gravity: planck.Vec2(0, -10),
            velocityIterations: 30,
            positionIterations: 30
        });

        var ground = world.createBody({
            type: 'static'
        });
        
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin, height-wallThickness),pixelsToMeters(width-rightMargin, height-wallThickness))
        });
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(leftMargin, height-wallThickness),pixelsToMeters(leftMargin, 0))
        });
        
        ground.createFixture({
            shape: planck.Edge(pixelsToMeters(width-rightMargin, height-wallThickness),pixelsToMeters(width-rightMargin, 0))
        });

        var blabla = 1
        function addCircle(x, y, color, size){
            //create circle sprite
            var circle = new PIXI.Sprite(circleTextures[color][size]);
            circle.anchor.set(0.5);
            circle.x = x;
            circle.y = y;
            circlesLayer.addChild(circle);

            //create shadow sprite
            var shadow = new PIXI.Sprite(shadowTextures[color][size][0]);
            shadow.anchor.set(0.5);
            shadow.x = x;
            shadow.y = y;
            shadowLayer[0].addChild(shadow);

            // add to global list of sprites
            // circles.push({'circle':circle, 'shadow':shadow});


            body = world.createDynamicBody(pixelsToMeters(x, y));
            body.createFixture({
                shape: planck.Circle((size+1)/80.0),
                density: blabla,
                friction: 0,
                restitution: 0
            });
            body._circle = circle
            body._shadow = shadow
            body.circleColor = color
            body.circleSize = size
            body.groupSize = 1
            body._edges = []
        }
        // addCircle(width/2+100, 0, 'red', 25)
        // addCircle(width/2, 0, 'blue', 25)

        function mainLoop(){
            world.step(1 / 60);
            // iterate over bodies and fixtures
            while(joints_to_make.length > 0){
                jointdef = joints_to_make.pop()
                joint = world.createJoint(jointdef)
            }
            while(bodies_to_destroy.length > 0){
                body = bodies_to_destroy.pop()
                world.destroyBody(body)
            }

            
            
            for (var body = world.getBodyList(); body; body = body.getNext()) {
                for (var fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
                    if(fixture.m_density <= 0){continue}
                    _body = fixture.getBody()
                    var destroyed = false;
                    //console.log(_body.getContactList())
                    for (var contact = _body.getContactList(); contact; contact = contact.next) {
                        if(contact.other.m_type == "static"){continue}
                        cbody = contact.other
                        //console.log(_body.circleColor, cbody.circleColor)
                        if (_body.circleColor == cbody.circleColor){
                            
                            // resize body
                            // bla = _body.getFixtureList();
                            // _shape = bla.shape
                            // _body.destroyFixture(bla)
                            // _body.createFixture({
                            //     shape: planck.Circle((60)/80.0),
                            //     density: blabla,
                            //     friction: 0,
                            //     restitution: 0
                            // });


                            // destroy both bodies render and physics
                            // world.destroyBody(_body)
                            // world.destroyBody(cbody)
                            // pxCircle = circles[_body.circleId]['circle']
                            // pxShadow = circles[_body.circleId]['shadow']
                            // circlesLayer.removeChild(pxCircle);
                            // shadowLayer.removeChild(pxShadow);
                            // pxCircle = circles[cbody.circleId]['circle']
                            // pxShadow = circles[cbody.circleId]['shadow']
                            // circlesLayer.removeChild(pxCircle);
                            // shadowLayer.removeChild(pxShadow);
                            
                            
                            //destroyed = true;
                            
                            //break
                        }
                    }
                    if(destroyed){continue}
                    pxCircle = _body._circle//circles[_body.circleId]['circle']
                    pxShadow = _body._shadow//circles[_body.circleId]['shadow']
                    _ = _body.getPosition()

                    __ = metersToPixels(_['x'], _['y'])

                    pxCircle.x = __[0], pxCircle.y = __[1];
                    pxShadow.x = __[0], pxShadow.y = __[1];
                    
                }
            }
            window.requestAnimationFrame(mainLoop);
        };

        window.requestAnimationFrame(mainLoop);
        console.log(planck)
        joints_to_make = []
        bodies_to_destroy = []
        world.on('begin-contact', function(fixturePair) {
            body_a = fixturePair.getFixtureA().getBody()
            body_b = fixturePair.getFixtureB().getBody()
            if(body_a.m_type == "static" || body_b.m_type == "static"){
                return
            }
            if(body_a.circleColor != body_b.circleColor){
                return
            }
            


            if(! body_a._edges.includes(body_b)){
                body_a._edges.push(body_b)
                body_b._edges.push(body_a)
                newGroupSize = body_a.groupSize + body_b.groupSize
                start = body_a.groupSize > body_b.groupSize ? body_a : body_b
                start.groupSize = newGroupSize
                q = [start]
                visited = [start]

                if(newGroupSize <= 3 && body_a._edges.length <= 2 && body_b._edges.length <= 2){
                    bodyAPos = body_a.getPosition()
                    bodyBPos = body_b.getPosition()
                    jointdef = planck.DistanceJoint(100, body_a, body_b, bodyAPos, bodyBPos)
                    jointdef.setLength((body_a.circleSize + body_b.circleSize)/80);
                    joints_to_make.push(jointdef)
                }

                while(q.length>0){
                    node = q.pop()
                    if(newGroupSize >= 5){
                        bodies_to_destroy.push(node)
                        pxCircle = node._circle
                        pxShadow = node._shadow
                        circlesLayer.removeChild(pxCircle);
                        shadowLayer[0].removeChild(pxShadow);
                        shadowLayer[1].removeChild(pxShadow);
                        shadowLayer[2].removeChild(pxShadow);
                        shadowLayer[3].removeChild(pxShadow);
                    }else{
                        node.groupSize = newGroupSize
                        node._shadow.texture = shadowTextures[node.circleColor][node.circleSize][Math.min(newGroupSize-1, 3)];
                        node._shadow.setParent(shadowLayer[Math.min(newGroupSize-1, 3)])
                    }
                    for(i=0;i<node._edges.length;i++){
                        nNode = node._edges[i]
                        if(! visited.includes(nNode)){
                            q.push(nNode)
                            visited.push(nNode)
                            nNode.groupSize = newGroupSize
                        }
                    }
                }


            }

            // body_a._shadow.texture = shadowTextures[body_a.circleColor][body_a.circleSize][Math.min(body_a._edges.length, 3)];
            // body_b._shadow.texture = shadowTextures[body_b.circleColor][body_b.circleSize][Math.min(body_b._edges.length, 3)];
            // body_a._shadow.setParent(shadowLayer[Math.min(body_a.groupSize-1, 3)])
            // body_b._shadow.setParent(shadowLayer[Math.min(body_b.groupSize-1, 3)])
            // console.log(Math.min(body_a._edges.length, 3), Math.min(body_b._edges.length, 3))
        });
        world.on('end-contact', function(fixturePair) {
            // body_a = fixturePair.getFixtureA().getBody()
            // body_b = fixturePair.getFixtureB().getBody()
            // if(body_a.m_type == "static" || body_b.m_type == "static"){
            //     return
            // }
            // if(body_a.circleColor != body_b.circleColor){
            //     return
            // }
            // if(body_a._edges.includes(body_b)){
            //     var index = body_a._edges.indexOf(body_b)
            //     //body_a._edges.splice(index, 1)
            // }
            // if(body_b._edges.includes(body_a)){
            //     var index = body_b._edges.indexOf(body_a)
            //     //body_b._edges.splice(index, 1)
            // }
        });
        function bla(){
            randInt = Math.floor(Math.random() * Math.floor(width-leftMargin-rightMargin-100));

            addCircle(randInt+leftMargin+50, -100, ['blue', 'red', 'green', 'purple', 'yellow', 'orange'][Math.floor(Math.random() * 6)], [25, 15, 40][Math.floor(Math.random() * 3)])
            window.setTimeout('bla()', 100)
        }
        //window.setTimeout('bla()', 200)
        window.onclick = function(){
            randInt = Math.floor(Math.random() * Math.floor(width-leftMargin-rightMargin-100));

            addCircle(randInt+leftMargin+50, -100, ['blue', 'red', 'green', 'purple', 'yellow', 'orange'][Math.floor(Math.random() * 6)], [25, 15, 40][Math.floor(Math.random() * 3)])
        }
        
    </script>
</body></html>
